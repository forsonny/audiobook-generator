{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Project Repository",
      "description": "Initialize the project repository with Electron, React/Vue, Python, and required dependencies.",
      "details": "Create a new repository with a README, .gitignore, and basic structure for Electron (frontend) and Python (backend). Install Node.js, Python 3.8+, and required libraries (Flask/FastAPI, spaCy/NLTK, Hugging Face Transformers, PyDub, FFmpeg, SQLite). Set up a basic build and run script for both frontend and backend.",
      "testStrategy": "Verify repository structure, successful installation of dependencies, and ability to run a basic Electron app and Python server.",
      "priority": "high",
      "dependencies": [],
      "status": "in-progress",
      "subtasks": [
        {
          "id": 1,
          "title": "Frontend Initialization",
          "description": "Set up the frontend framework (React or Vue) within the Electron project, initializing the project structure and configuration files.",
          "dependencies": [],
          "details": "Use Vue CLI or Create React App to scaffold the frontend. Integrate with Electron using plugins or manual configuration as needed.\n<info added on 2025-05-12T01:28:16.069Z>\nUse Vue CLI or Create React App to scaffold the frontend. Integrate with Electron using plugins or manual configuration as needed.\n\n<update timestamp=\"2025-05-12T01:28:11Z\">\nFrontend initialization completed using native HTML, CSS, and JavaScript for simplicity and rapid prototyping. The structure includes:\n- Main Electron entry point (src/main.js) for application lifecycle management.\n- Preload script (src/preload.js) to facilitate secure IPC communication between the main and renderer processes.\n- Basic HTML UI (src/index.html) implementing the card-based layout and green color scheme as per the mockups.\n- CSS styling (src/styles.css) with CSS variables for consistent theming and maintainability.\n- Renderer JavaScript (src/renderer.js) handling UI interactions and initializing the card-based interface.\n\nThe setup avoids framework overhead for the initial phase, focusing on modular organization and adherence to the provided UI mockups. This approach allows for straightforward integration with a frontend framework (React or Vue) in future iterations, if needed.\n</update>\n</info added on 2025-05-12T01:28:16.069Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Backend Setup",
          "description": "Configure the backend component (e.g., Python or Node.js), ensuring it can communicate with the Electron frontend.",
          "dependencies": [
            1
          ],
          "details": "Set up the backend server, define API endpoints, and establish IPC or HTTP communication between Electron and the backend.\n<info added on 2025-05-12T01:28:30.984Z>\n<update><timestamp>2025-05-12T01:28:26Z</timestamp><content>The backend has been successfully configured using FastAPI, a modern Python web framework known for its speed and ease of use. The main application file (src/backend/app.py) initializes the FastAPI server and defines core API endpoints for book import, character analysis, audio generation, and project management. These endpoints are designed to facilitate seamless communication with the Electron frontend via HTTP requests. The backend architecture is modular, with dedicated service files for TTS (src/backend/tts_service.py, integrating Kokoro TTS) and AI text analysis (src/backend/gemini_service.py, leveraging Gemini models). All required Python dependencies are listed in src/backend/requirements.txt, ensuring a reproducible development environment. The codebase is structured for extensibility, with clear separation of concerns and robust error handling mechanisms in place. This setup supports future integration of additional services and features as the project evolves.</content></update>\n</info added on 2025-05-12T01:28:30.984Z>",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Dependency Installation",
          "description": "Install all required dependencies for both frontend and backend, including Electron, framework libraries, and any additional packages.",
          "dependencies": [
            1,
            2
          ],
          "details": "Use npm, yarn, or pip to install dependencies such as electron, electron-is-dev, and any UI libraries or backend packages.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Build Script Creation",
          "description": "Create and configure build scripts for development and production, ensuring proper build and launch of both frontend and backend components.",
          "dependencies": [
            3
          ],
          "details": "Add or modify scripts in package.json or equivalent to handle building, serving, and packaging the application for different environments.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Testing Configuration",
          "description": "Set up testing frameworks and configuration for both frontend and backend, enabling automated and manual testing.",
          "dependencies": [
            4
          ],
          "details": "Integrate testing tools (e.g., Jest, Mocha, Pytest), configure test scripts, and ensure tests can run in the Electron environment.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 2,
      "title": "Design and Implement Core UI Structure",
      "description": "Implement the three-panel UI layout (Navigation, Workspace, Settings) as per design specifications.",
      "details": "Use React/Vue to create the main application window with three panels. Implement responsive behavior, color palette, and typography as specified. Add basic navigation and settings panels with placeholder content.",
      "testStrategy": "Manual UI review and automated snapshot testing to ensure layout matches design specs. Test responsive behavior on different screen sizes.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Book Import and Parsing",
      "description": "Enable users to import books in EPUB, PDF, and TXT formats, extract structured text with precise chapter and paragraph preservation, extract metadata, and create projects with the specified folder structure. The implementation must match the exact visual layout, components, and workflow shown in the book-import-screen.png mockup located in Project/UI Mockups/.",
      "status": "pending",
      "dependencies": [
        1,
        2
      ],
      "priority": "high",
      "details": "Use Electron file dialogs for file selection and drag-and-drop, ensuring the UI matches the book-import-screen.png mockup in Project/UI Mockups/. Implement parsers for EPUB (epub.js or similar), PDF (pdf.js or PyPDF2), and TXT with UTF-8 encoding detection and handling. Extract metadata (title, author, publication date) and preserve structure (chapters, paragraphs) exactly as described in the Technical Specification for backend parser modules. Store parsed content in SQLite and local filesystem following the Project Data Structure for project creation. The UI must include the drag-and-drop area, book type selection, processing options, and recently added books section as shown in the mockup. The file selection dialog, supported formats display, and import button styling must be implemented exactly as shown in the mockup. Show progress and handle errors.",
      "testStrategy": "Test import of sample files in each format with emphasis on UTF-8 encoding handling for TXT files. Verify metadata extraction (title, author, publication date), exact preservation of chapter boundaries and paragraph structure, adherence to backend parser file structure, and correct project folder creation. Validate error handling and progress reporting. Confirm that the UI, including drag-and-drop area, book type selection, processing options, recently added books section, file selection dialog, supported formats display, and import button styling, matches the book-import-screen.png mockup exactly.",
      "subtasks": [
        {
          "id": 1,
          "title": "Design and implement file selection UI",
          "description": "Create a user interface component that allows users to browse and select book files in EPUB, PDF, and TXT formats",
          "dependencies": [],
          "details": "Implement file browser dialog, file type filtering, multiple file selection capability, and preview thumbnails. Include validation for supported file formats and file size limitations. The UI must match the layout and styling shown in book-import-screen.png in Project/UI Mockups/, including the drag-and-drop area, supported formats display, and import button styling.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop EPUB parser module",
          "description": "Create a parser to extract content and structure from EPUB format books",
          "dependencies": [
            1
          ],
          "details": "Implement EPUB archive extraction, XML/XHTML content parsing, CSS handling, image extraction, and table of contents mapping. Handle various EPUB versions (2.0, 3.0, 3.1) and implement error handling for malformed EPUB files. Ensure metadata extraction (title, author, publication date) and precise preservation of chapter and paragraph structure as per Technical Specification.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Develop PDF parser module",
          "description": "Create a parser to extract text content, formatting, and structure from PDF documents",
          "dependencies": [
            1
          ],
          "details": "Implement text extraction with proper reading order, handle embedded fonts, extract images, parse document structure (chapters, sections), and implement OCR fallback for scanned PDFs. Account for password-protected PDFs and various PDF versions. Extract metadata (title, author, publication date) and preserve chapter and paragraph boundaries exactly as specified.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Develop TXT parser module",
          "description": "Create a parser to process plain text files with UTF-8 encoding detection and basic formatting detection",
          "dependencies": [
            1
          ],
          "details": "Implement UTF-8 encoding detection and handling, basic structure inference (chapters, paragraphs), handle line breaks and whitespace normalization, and detect potential metadata from text patterns. Ensure precise preservation of chapter boundaries and paragraph structure.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement metadata extraction system",
          "description": "Create a unified system to extract and normalize metadata from all supported file formats",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Extract title, author, publication date, ISBN, publisher, language, and cover images. Implement fallback strategies when metadata is missing, integrate with external metadata sources for enrichment, and normalize metadata across different formats. Ensure metadata extraction aligns with the Technical Specification.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Develop database storage implementation",
          "description": "Create a storage solution to save parsed books and their metadata in the database",
          "dependencies": [
            5
          ],
          "details": "Design database schema for books, metadata, and content storage. Implement transaction handling for atomic imports, optimize for both search performance and storage efficiency, and create indexing for full-text search capabilities. Store parsed content and metadata following the Project Data Structure for project folder creation.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 4,
      "title": "Integrate Kokoro TTS Model",
      "description": "Download, initialize, and integrate the Kokoro TTS model for local text-to-speech conversion with support for custom voices and streaming functionality.",
      "status": "pending",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Download the Kokoro TTS model (hexgrad/Kokoro-82M) from Hugging Face and set up for local deployment. Implement Docker container integration with FastAPI for REST API architecture. Support both GPU and CPU implementations, voice customization parameters (pitch, speed, energy), and streaming TTS functionality for previewing.",
      "testStrategy": "Test model download, initialization, and basic TTS synthesis with sample text. Verify audio output quality with multiple voice options including AFSky and AFSarah. Test both GPU and CPU modes, custom voice blending, and streaming functionality.",
      "subtasks": [
        {
          "id": 1,
          "title": "Model Download and Initialization",
          "description": "Download the required TTS model files and initialize the TTS engine or SDK, ensuring all dependencies and environment variables are set up for the chosen provider.",
          "dependencies": [],
          "details": "This includes setting up authentication, configuring API keys or credentials, and verifying that the model loads correctly in the runtime environment.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Text Normalization Implementation",
          "description": "Develop and integrate a text normalization module to preprocess input text, handling punctuation, numbers, abbreviations, and other linguistic variations to improve synthesis quality.",
          "dependencies": [
            1
          ],
          "details": "Ensure the normalization process is compatible with the requirements of the TTS model and supports the expected input formats.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Basic Synthesis Functionality",
          "description": "Implement the core functionality to convert normalized text into speech using the initialized TTS model, and output the resulting audio.",
          "dependencies": [
            2
          ],
          "details": "This includes handling API calls or SDK methods for synthesis, managing audio output, and basic error handling.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Performance Optimization",
          "description": "Optimize the TTS integration for performance by implementing caching, efficient resource management, and minimizing latency during synthesis.",
          "dependencies": [
            3
          ],
          "details": "Analyze bottlenecks, apply caching strategies for repeated requests, and ensure the system scales efficiently under load.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Environment Setup with PyTorch and CUDA",
          "description": "Set up the required environment with PyTorch and specific CUDA versions to support Kokoro TTS model.",
          "dependencies": [],
          "details": "Install PyTorch with appropriate CUDA support for GPU acceleration. Ensure compatibility with the Kokoro-82M model requirements. Configure fallback to CPU mode when GPU is not available.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Docker Container and FastAPI Integration",
          "description": "Set up Kokoro FastAPI using Docker for both CPU and GPU implementations.",
          "dependencies": [
            1,
            5
          ],
          "details": "Create Docker container configuration for Kokoro TTS. Implement FastAPI endpoints for text-to-speech conversion. Configure Docker authentication process and ensure proper container integration.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Voice Customization Implementation",
          "description": "Implement support for voice customization parameters including pitch, speed, and energy.",
          "dependencies": [
            3
          ],
          "details": "Add API parameters for adjusting voice characteristics. Support multiple voice options including AFSky and AFSarah. Implement voice blending functionality for custom voice creation.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Streaming TTS Functionality",
          "description": "Implement streaming TTS functionality for real-time audio preview.",
          "dependencies": [
            3,
            6
          ],
          "details": "Create streaming endpoint in the FastAPI implementation. Ensure low-latency audio streaming for preview purposes. Handle connection management and error cases during streaming.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 5,
      "title": "Implement Basic TTS Audio Generation",
      "description": "Generate speech audio from text segments using Kokoro TTS and assigned voice parameters, with enhanced text editing and audio visualization features. The implementation must match the exact visual layout and components shown in Project/UI Mockups/text-editor-screen.png. This includes the text editor with dialogue highlighting, character attribution tags, AI confidence percentages, chapter navigation, and text analysis panel. The waveform visualization, pagination controls, and editing tools must be implemented exactly as shown in the mockup.",
      "status": "pending",
      "dependencies": [
        4
      ],
      "priority": "high",
      "details": "Implement batch processing of text segments. Apply voice parameters (pitch, speed, style) to TTS output. Store generated audio segments in local filesystem. Add progress indication. Integrate drag-and-drop chapter ordering functionality. Implement text highlighting for selected text. Support split-view editing mode with synchronized text and waveform views. Add automatic paragraph detection and formatting. Include support for custom CSS styling of the text editor. Implement find/replace functionality with regex support. Add support for custom user annotations. All UI and interaction must match the layout and components in Project/UI Mockups/text-editor-screen.png, including dialogue highlighting, character attribution tags, AI confidence percentages, chapter navigation, text analysis panel, waveform visualization, pagination controls, and editing tools.",
      "testStrategy": "Test batch TTS generation with different voice parameters. Verify audio files are generated and stored correctly. Test drag-and-drop chapter ordering functionality. Verify text highlighting works correctly. Test split-view editing mode synchronization. Verify automatic paragraph detection. Test custom CSS styling application. Verify find/replace with regex support. Test custom user annotations functionality. Confirm that all UI elements and interactions match Project/UI Mockups/text-editor-screen.png, including dialogue highlighting, character attribution tags, AI confidence percentages, chapter navigation, text analysis panel, waveform visualization, pagination controls, and editing tools.",
      "subtasks": [
        {
          "id": 5.1,
          "title": "Implement core TTS audio generation",
          "description": "Set up Kokoro TTS integration and implement basic text-to-speech conversion. Ensure the audio generation workflow and UI match the layout and components shown in Project/UI Mockups/text-editor-screen.png, including waveform visualization and editing tools.",
          "status": "pending"
        },
        {
          "id": 5.2,
          "title": "Implement drag-and-drop chapter ordering",
          "description": "Create functionality to allow users to reorder chapters via drag-and-drop in the UI. The chapter navigation must match the appearance and behavior shown in Project/UI Mockups/text-editor-screen.png.",
          "status": "pending"
        },
        {
          "id": 5.3,
          "title": "Add text highlighting for selected text",
          "description": "Implement highlighting functionality for selected text as shown in the mockups, including dialogue highlighting and character attribution tags as depicted in Project/UI Mockups/text-editor-screen.png.",
          "status": "pending"
        },
        {
          "id": 5.4,
          "title": "Implement split-view editing mode",
          "description": "Create synchronized split-view with text editor and waveform visualization, matching the layout and interaction shown in Project/UI Mockups/text-editor-screen.png.",
          "status": "pending"
        },
        {
          "id": 5.5,
          "title": "Add automatic paragraph detection",
          "description": "Implement automatic detection and formatting of paragraphs in imported text. Ensure paragraph formatting and display match the mockup in Project/UI Mockups/text-editor-screen.png.",
          "status": "pending"
        },
        {
          "id": 5.6,
          "title": "Support custom CSS styling",
          "description": "Add support for applying custom CSS styles to the text editor, ensuring compatibility with the visual requirements in Project/UI Mockups/text-editor-screen.png.",
          "status": "pending"
        },
        {
          "id": 5.7,
          "title": "Implement find/replace with regex",
          "description": "Create find/replace functionality with support for regular expressions, matching the UI and controls as shown in Project/UI Mockups/text-editor-screen.png.",
          "status": "pending"
        },
        {
          "id": 5.8,
          "title": "Add custom user annotations",
          "description": "Implement support for users to add and manage custom annotations in the text, ensuring annotation display and controls match Project/UI Mockups/text-editor-screen.png.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement Audio File Management and Export",
      "description": "Manage, concatenate, and export audio segments into complete audiobooks, supporting advanced export formats, metadata, and batch processing. The implementation must match the exact visual layout and components shown in export-screen.png (located in Project/UI Mockups/). This includes the audiobook chapters listing with duration and status indicators, export format selection, audio quality options, metadata fields, advanced options toggles, the file details panel, and export/save buttons as depicted in the mockup.",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "high",
      "details": "Use PyDub/FFmpeg to concatenate audio segments into chapters and full audiobooks. Normalize volume, add chapter markers (including M4B support), and export in MP3, M4B, WAV, and OGG formats. Embed metadata (title, author, cover art, etc.) in exported files. Implement file size optimization options as described in the technical specification. Provide customizable export settings for sample rate, bit depth, and compression profiles. Implement batch export functionality with progress reporting. Implement playback for segments, chapters, and full audiobooks. The export screen UI must match export-screen.png in Project/UI Mockups/, including: audiobook chapters listing with duration and status indicators, export format selection, audio quality options, metadata fields, advanced options toggles, file details panel, and export/save buttons.",
      "testStrategy": "Test concatenation, export, and playback of sample audiobooks. Verify chapter markers (including M4B compatibility), metadata embedding, and export in all supported formats (MP3, M4B, WAV, OGG). Test file size optimization, customizable export settings, and batch export with progress reporting. Confirm that the export screen UI matches export-screen.png in Project/UI Mockups/ in all visual and interactive aspects, including chapters listing, export format selection, audio quality options, metadata fields, advanced options toggles, file details panel, and export/save buttons.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Audio Segment Concatenation",
          "description": "Develop functionality to join multiple audio segments into a single continuous file while preserving audio quality",
          "dependencies": [],
          "details": "Create methods to handle different audio formats, ensure seamless transitions between segments, implement error handling for incompatible formats, and optimize for memory efficiency when dealing with large audio files",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop Volume Normalization System",
          "description": "Create a system to analyze and adjust volume levels across all audio segments to ensure consistent listening experience",
          "dependencies": [
            1
          ],
          "details": "Implement RMS or LUFS analysis algorithms, create configurable normalization targets, develop preview functionality, and ensure processing doesn't introduce artifacts or distortion",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Build Chapter Marker Implementation",
          "description": "Design and implement a system for adding, editing, and managing chapter markers within the audio file, including M4B compatibility",
          "dependencies": [
            1
          ],
          "details": "Create data structures to store chapter metadata, develop UI components for marker visualization and editing, implement timestamp validation, and ensure markers are preserved during export to compatible formats, including M4B files",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Create Export Functionality",
          "description": "Develop comprehensive export capabilities supporting multiple audio formats with metadata embedding, file size optimization, and customizable export settings",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implement FFmpeg integration for format conversion supporting MP3, M4B, WAV, and OGG. Ensure chapter markers (including M4B), metadata (title, author, cover art, etc.), and file size optimization options are properly handled. Provide customizable export settings for sample rate, bit depth, and compression profiles. Implement batch export functionality with progress reporting. The export screen UI must match export-screen.png in Project/UI Mockups/, including: audiobook chapters listing with duration and status indicators, export format selection, audio quality options, metadata fields, advanced options toggles, file details panel, and export/save buttons.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement Playback Features",
          "description": "Build audio playback functionality with transport controls, visualization, and chapter navigation",
          "dependencies": [
            1,
            3
          ],
          "details": "Develop transport controls (play, pause, seek), create waveform visualization, implement chapter-based navigation, add playback speed controls, and ensure accurate timestamp display during playback",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Implement Export Screen UI as per Mockup",
          "description": "Develop the export screen UI to match export-screen.png in Project/UI Mockups/ exactly, including all visual layout and components.",
          "dependencies": [
            4
          ],
          "details": "Ensure the export screen includes: audiobook chapters listing with duration and status indicators, export format selection, audio quality options, metadata fields, advanced options toggles, file details panel, and export/save buttons, all matching the mockup in layout and functionality.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 7,
      "title": "Implement Gemini API Integration for Text Analysis",
      "description": "Integrate Google Gemini API for advanced text analysis, character identification, and dialogue detection.",
      "details": "Implement API client for Gemini. Add endpoints for character identification, dialogue detection, and contextual analysis. Use local NLP (spaCy/NLTK) as fallback. Cache API responses for efficiency.",
      "testStrategy": "Test API integration with sample text. Verify character and dialogue detection accuracy. Test fallback to local NLP.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Gemini API Client",
          "description": "Set up the Gemini API client, including authentication, request handling, and response processing. Ensure secure storage of the API key and follow best practices for error handling and logging.",
          "dependencies": [],
          "details": "Register for an API key, securely store it, and initialize the Gemini API client using the appropriate SDK. Implement robust error handling, retries, and logging as recommended in the documentation.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop Character Identification Endpoint",
          "description": "Create an endpoint that leverages the Gemini API to identify characters from input data.",
          "dependencies": [
            1
          ],
          "details": "Design the endpoint to accept relevant input, call the Gemini API for character identification, and return structured results. Ensure proper request formatting and response parsing.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Develop Dialogue Detection Endpoint",
          "description": "Create an endpoint that uses the Gemini API to detect dialogue within input data.",
          "dependencies": [
            1
          ],
          "details": "Design the endpoint to process input, interact with the Gemini API for dialogue detection, and return results in a consistent format. Handle errors and edge cases appropriately.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Fallback NLP Functionality",
          "description": "Develop local NLP-based fallback logic for character identification and dialogue detection in case the Gemini API is unavailable.",
          "dependencies": [
            2,
            3
          ],
          "details": "Integrate open-source or custom NLP models to provide basic character identification and dialogue detection when API calls fail or rate limits are reached.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Integrate Response Caching Mechanism",
          "description": "Implement a caching layer to store and retrieve Gemini API responses for repeated requests, reducing latency and API usage.",
          "dependencies": [
            2,
            3
          ],
          "details": "Design and implement a cache (e.g., in-memory or persistent) keyed by request parameters. Ensure cache invalidation and consistency with API updates.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 8,
      "title": "Implement Dialogue and Narration Identification",
      "description": "Distinguish between dialogue and narration using Gemini API and rule-based methods.",
      "status": "pending",
      "dependencies": [
        3,
        7
      ],
      "priority": "medium",
      "details": "Implement hybrid approach (Gemini + rule-based) for dialogue detection. Segment text into dialogue and narration. Allow manual correction in UI. Feed corrections back to Gemini for improvement. Use context-aware dialogue detection with multi-pass analysis for longer texts. Handle complex literary techniques and integrate with character identification system. Implement offline NLP fallback pipeline.",
      "testStrategy": "Test dialogue/narration segmentation on sample books. Verify manual correction and feedback loop. Test handling of complex literary techniques including internal monologues and nested quotations. Validate integration with character identification system. Verify offline processing capabilities.",
      "subtasks": [
        {
          "id": 1,
          "title": "Gemini API Integration for Dialogue Identification",
          "description": "Integrate the Gemini API to enable AI-driven dialogue identification, leveraging its NLP capabilities for initial detection and classification of dialogue segments.",
          "dependencies": [],
          "details": "Set up authentication, configure endpoints, and ensure the API can process text inputs for dialogue identification tasks. Implement context-aware dialogue detection using Gemini's multi-turn conversation capabilities. Use the GenerativeModel class with appropriate model version (gemini-2.0-flash) for optimal performance.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Rule-Based Dialogue Detection Implementation",
          "description": "Develop and implement rule-based methods to complement AI-driven dialogue identification, focusing on explicit patterns and linguistic cues.",
          "dependencies": [
            1
          ],
          "details": "Design rules for speaker turns, punctuation, and dialogue markers to enhance or validate AI predictions. Implement specific dialogue classification algorithms based on quotation marks, surrounding context, and dialogue attributions. Add support for detecting complex literary techniques like internal monologues and nested quotations.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Text Segmentation for Dialogue Units",
          "description": "Segment input text into discrete dialogue units, preparing data for both AI and rule-based processing.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement algorithms to split text into sentences, utterances, or speaker turns as required by downstream modules. Implement multi-pass analysis approach for handling longer texts, with initial segmentation followed by detailed analysis of each segment.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "UI for Manual Corrections of Dialogue Segmentation",
          "description": "Develop a user interface that allows manual review and correction of dialogue segmentation results.",
          "dependencies": [
            3
          ],
          "details": "Design UI components for displaying segmented dialogues, enabling users to adjust boundaries and labels as needed.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Feedback Loop Implementation for Continuous Improvement",
          "description": "Implement a feedback mechanism to capture user corrections and improve both AI and rule-based models over time.",
          "dependencies": [
            4
          ],
          "details": "Design data pipelines to collect corrections, retrain models, and update rules based on user feedback.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Character Identification System Integration",
          "description": "Integrate with the character identification system to properly attribute dialogue to specific characters.",
          "dependencies": [
            2,
            3
          ],
          "details": "Develop interfaces to connect dialogue segments with character entities. Implement logic to associate dialogue with speakers based on context and explicit attributions. Update the dialogue model to include character references.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Offline NLP Fallback Pipeline",
          "description": "Implement a fallback NLP pipeline for offline processing when Gemini API is unavailable.",
          "dependencies": [
            1
          ],
          "details": "Develop a local NLP solution using open-source libraries that can process text when cloud services are unavailable. Implement seamless switching between online and offline modes. Ensure consistent dialogue identification results between both processing methods.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Complex Literary Techniques Support",
          "description": "Enhance the dialogue detection system to handle complex literary techniques beyond standard dialogue.",
          "dependencies": [
            2,
            3
          ],
          "details": "Implement specialized detection for internal monologues, stream of consciousness, nested quotations, and other non-standard dialogue forms. Train Gemini with examples of these literary techniques to improve recognition accuracy.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 9,
      "title": "Implement Character Identification and Management",
      "description": "Identify characters, assign dialogue, and manage character profiles using Gemini API with fallback NLP system for offline operation. Implement UI according to character-voice-screen.png mockup.",
      "status": "pending",
      "dependencies": [
        3,
        7
      ],
      "priority": "medium",
      "details": "Integrate Gemini 2.0 Flash model for character detection, pronoun resolution, and alias merging. Implement CharacterAnalyzer service for deep character analysis. Structure character data in JSON format. Assign dialogue segments to characters. Create character registry with AI-generated profiles. Allow manual management in UI that exactly matches the character-voice-screen.png mockup in Project/UI Mockups/ directory, including character profile displays with initials, AI detection badges, confidence percentages, character statistics, descriptions, voice preview players, and parameter sliders.",
      "testStrategy": "Test character detection and assignment on sample books. Verify manual management and profile generation match the mockup exactly. Test batch actions and voice library filtering system. Ensure fallback NLP system works when offline.",
      "subtasks": [
        {
          "id": 1,
          "title": "Character Detection System",
          "description": "Develop a robust character detection system that identifies named entities and potential character references in text",
          "dependencies": [],
          "details": "Implement NLP techniques to recognize character names, titles, and descriptive references. Include handling of capitalized proper nouns, character introductions, and contextual clues for unnamed characters. Consider using named entity recognition (NER) models with custom training for literary contexts.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Pronoun Resolution Module",
          "description": "Create a module that accurately resolves pronouns to their respective character entities",
          "dependencies": [
            1
          ],
          "details": "Develop algorithms for anaphora resolution that can handle complex pronoun references across paragraphs. Account for gender, number, and grammatical role when linking pronouns to characters. Implement confidence scoring for ambiguous cases that might require manual verification.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Alias Merging Framework",
          "description": "Build a system to identify and merge different aliases, nicknames, and references to the same character",
          "dependencies": [
            1
          ],
          "details": "Create similarity metrics and contextual analysis tools to determine when different names refer to the same entity. Handle diminutives, titles, and relationship-based references (e.g., 'his mother'). Implement both rule-based and machine learning approaches for optimal accuracy.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Dialogue Assignment Engine",
          "description": "Develop functionality to accurately assign dialogue to the correct speaking characters",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Create pattern recognition for dialogue markers and speaker attribution. Handle implicit speakers, conversation flow, and interruptions. Integrate with the pronoun resolution and character detection systems to maintain consistency in speaker identification throughout extended dialogues.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Character Profile Generator",
          "description": "Implement a system that compiles comprehensive character profiles from detected information",
          "dependencies": [
            1,
            3,
            4
          ],
          "details": "Aggregate character information including attributes, relationships, dialogue patterns, and narrative importance. Design data structures to store character hierarchies and relationships. Include extraction of character traits, motivations, and development arcs from contextual analysis. Ensure profiles include dialogue line counts and other statistics shown in the character-voice-screen.png mockup.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Manual Management UI",
          "description": "Design and implement a user interface for manual review and editing of character information",
          "dependencies": [
            5
          ],
          "details": "Create an intuitive interface for reviewing automated character detection results and making corrections. Implement the exact visual layout and components shown in character-voice-screen.png mockup, including character profile display with initials, AI detection badges, confidence percentages, character statistics (dialogue lines), character description, voice preview players, and voice parameter sliders. Include batch actions section and voice library filtering system as shown in the mockup.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Gemini API Integration",
          "description": "Integrate Gemini 2.0 Flash model for character analysis with structured JSON output",
          "dependencies": [],
          "details": "Implement API calls to Gemini 2.0 Flash model for character detection and analysis. Create _build_character_prompt function to format requests properly. Handle API responses and parse JSON structure for character data. Implement error handling and rate limiting according to Gemini API guidelines.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "CharacterAnalyzer Service Implementation",
          "description": "Develop the CharacterAnalyzer service for deep character analysis on book text",
          "dependencies": [
            7
          ],
          "details": "Create a service that processes book text to extract comprehensive character information. Implement methods for character role identification, relationship inference, and personality trait extraction. Ensure the service can handle large text volumes by processing in manageable chunks.",
          "status": "pending"
        },
        {
          "id": 9,
          "title": "Character Merging Logic",
          "description": "Implement logic to handle the same character identified across different contexts",
          "dependencies": [
            3,
            7,
            8
          ],
          "details": "Develop algorithms to identify when different character references point to the same entity. Create confidence scoring for potential matches and implement merge operations that preserve all relevant character data. Handle edge cases like unreliable narrators or intentionally ambiguous character identities.",
          "status": "pending"
        },
        {
          "id": 10,
          "title": "Fallback NLP System",
          "description": "Implement a fallback NLP system for offline character analysis operation",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Develop a local NLP pipeline that can perform basic character identification and dialogue attribution when Gemini API is unavailable. Optimize for performance on limited hardware. Create seamless switching between online and offline modes with appropriate user notification.",
          "status": "pending"
        },
        {
          "id": 11,
          "title": "Character Relationship Inference",
          "description": "Implement methods for inferring relationships between characters",
          "dependencies": [
            8,
            9
          ],
          "details": "Develop algorithms to detect and categorize relationships between characters based on dialogue, narrative context, and explicit statements. Create a relationship graph data structure to represent character connections. Include confidence scoring for inferred relationships and support for complex relationship types.",
          "status": "pending"
        },
        {
          "id": 12,
          "title": "Voice Preview Player Implementation",
          "description": "Implement voice preview players for character profiles as shown in the mockup",
          "dependencies": [
            6
          ],
          "details": "Develop audio playback functionality for character voice samples. Implement play/pause controls and progress indicators as shown in the character-voice-screen.png mockup. Ensure seamless integration with the character profile display.",
          "status": "pending"
        },
        {
          "id": 13,
          "title": "Voice Parameter Sliders",
          "description": "Implement adjustable voice parameter sliders as shown in the mockup",
          "dependencies": [
            6,
            12
          ],
          "details": "Create interactive sliders for adjusting voice parameters such as pitch, speed, and other voice characteristics. Ensure real-time preview updates when parameters are changed. Match the exact visual style shown in the character-voice-screen.png mockup.",
          "status": "pending"
        },
        {
          "id": 14,
          "title": "Batch Actions Implementation",
          "description": "Implement batch action functionality for character management",
          "dependencies": [
            6
          ],
          "details": "Develop batch selection and action capabilities for efficient character management. Implement all batch actions shown in the character-voice-screen.png mockup, including multi-select, bulk editing, and batch processing options. Ensure the UI matches the mockup exactly.",
          "status": "pending"
        },
        {
          "id": 15,
          "title": "Voice Library Filtering System",
          "description": "Implement the voice library filtering system shown in the mockup",
          "dependencies": [
            6,
            12
          ],
          "details": "Create a comprehensive filtering system for the voice library as shown in the character-voice-screen.png mockup. Implement filter categories, search functionality, and sorting options. Ensure the filtering UI and behavior match the mockup exactly.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 10,
      "title": "Implement Voice Management and Assignment",
      "description": "Allow users to select and customize Kokoro TTS voices for characters and narrator.",
      "details": "Display available Kokoro TTS voices with preview. Map characters to voices with customizable parameters. Dedicated narrator configuration. Warn for unassigned characters.",
      "testStrategy": "Test voice selection, preview, and assignment. Verify warnings for unassigned characters.",
      "priority": "medium",
      "dependencies": [
        4,
        9
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Project Management System",
      "description": "Enable users to manage multiple audiobook projects, track progress, and handle project-specific settings according to the UI mockup specifications.",
      "status": "pending",
      "dependencies": [
        3,
        7
      ],
      "priority": "medium",
      "details": "Implement project creation, templates, and AI-powered genre/style detection (Gemini). Add library view with filtering, sorting, and search. Track processing history and API usage. Visual progress tracking. The implementation must match the exact visual layout and components shown in the UI mockup (Project/UI Mockups/ui-mockup.png), including the project overview screen with workflow visualization, progress tracking, settings panel, and status indicators.",
      "testStrategy": "Test project creation, management, and progress tracking. Verify genre/style detection and library features. Ensure all UI elements match exactly with the ui-mockup.png specifications, including layout, components, and visual styling.",
      "subtasks": [
        {
          "id": 1,
          "title": "Project Creation Module",
          "description": "Design and implement the core functionality for creating new projects, including data models, user input forms, and validation logic.",
          "dependencies": [],
          "details": "This subtask involves setting up the foundational data structures and interfaces required for users to initiate and define new projects, considering factors such as project name, description, team assignment, and initial settings. The UI must follow the exact layout and components shown in ui-mockup.png.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Template Implementation System",
          "description": "Develop a system for applying and managing project templates to streamline project setup and ensure consistency.",
          "dependencies": [
            1
          ],
          "details": "This includes creating reusable templates for common project types, integrating template selection into the project creation workflow, and allowing customization of template parameters. The template selection interface must match the design shown in ui-mockup.png.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Genre Detection Feature",
          "description": "Implement AI-powered genre detection to automatically classify projects based on their content or metadata.",
          "dependencies": [
            1
          ],
          "details": "Utilize machine learning or rule-based algorithms to analyze project data and assign a genre or category, enhancing organization and searchability. The genre detection UI components must match the mockup specifications.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Library View Interface",
          "description": "Create a comprehensive library view for browsing, filtering, and managing all projects within the system.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Design and build a user interface that displays projects in a structured manner, supports advanced filtering (including by genre), and provides quick access to project details. The library view must exactly match the layout shown in ui-mockup.png, including all filtering options and visual elements.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Progress Tracking System",
          "description": "Develop robust mechanisms for tracking project progress, milestones, and key performance indicators.",
          "dependencies": [
            1,
            2,
            4
          ],
          "details": "Implement features such as progress bars, milestone checklists, and reporting dashboards to monitor and visualize project advancement over time. The progress tracking visualization must match exactly with the workflow diagram shown in ui-mockup.png, including all status indicators and progress elements.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "API Usage Monitoring",
          "description": "Set up monitoring and analytics for all API interactions related to project management features.",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "Track API calls, measure performance, log errors, and generate usage reports to ensure reliability and support future scaling or optimization.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Project Settings Panel Implementation",
          "description": "Implement the project settings panel as shown in the UI mockup.",
          "dependencies": [
            1
          ],
          "details": "Develop the settings panel exactly as displayed in ui-mockup.png, including all configuration options, toggles, and input fields. The panel must maintain the same visual styling, layout, and functionality as depicted in the mockup.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Workflow Visualization Component",
          "description": "Implement the workflow diagram visualization component shown in the mockup.",
          "dependencies": [
            1,
            5
          ],
          "details": "Create the interactive workflow diagram exactly as shown in ui-mockup.png, including all nodes, connections, status indicators, and interactive elements. The visualization must accurately represent the project's current state and progress.",
          "status": "pending"
        },
        {
          "id": 9,
          "title": "Processing Options Implementation",
          "description": "Implement the processing options interface as shown in the mockup.",
          "dependencies": [
            1,
            7
          ],
          "details": "Develop all processing configuration options exactly as displayed in ui-mockup.png, including dropdown menus, sliders, checkboxes, and any other input controls. The layout and styling must match the mockup precisely.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 12,
      "title": "Implement API Key Management and Security",
      "description": "Securely manage API keys for Gemini and other services.",
      "details": "Store API keys in system keychain. Add UI for key input and validation. Handle authentication failures gracefully.",
      "testStrategy": "Test secure storage, UI input, and error handling for API keys.",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement User Feedback and Error Handling",
      "description": "Provide clear feedback, progress indication, and comprehensive error handling.",
      "details": "Add progress indicators, error messages, and recovery options throughout the UI. Log errors and user feedback for improvement.",
      "testStrategy": "Test error handling, progress indication, and feedback mechanisms.",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Implement Accessibility Features",
      "description": "Ensure UI is accessible (WCAG AA compliance, keyboard navigation, ARIA labels, text scaling).",
      "details": "Add ARIA labels, keyboard navigation, and support for text scaling. Test color contrast and accessibility features.",
      "testStrategy": "Manual and automated accessibility testing (axe-core, Lighthouse).",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Implement Offline Functionality",
      "description": "Enable core functionality (text processing, Kokoro TTS, audio export) to work offline after initial setup.",
      "details": "Cache models and required data during initial setup. Implement fallback for Gemini-dependent features. Test offline operation.",
      "testStrategy": "Test application operation without internet connection. Verify fallback and offline features.",
      "priority": "medium",
      "dependencies": [
        4,
        7
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Model Caching System",
          "description": "Design and implement a caching system for application models to ensure they're available offline",
          "dependencies": [],
          "details": "Create a robust caching mechanism that stores essential application models locally. This should include determining which models are critical for core functionality, implementing storage strategies that optimize for space and performance, and establishing cache invalidation policies for when connectivity is restored.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop Offline Data Storage Solution",
          "description": "Create a local database architecture that supports offline operations and data persistence",
          "dependencies": [],
          "details": "Implement a local database system that can store user data, application state, and necessary content. This should include schema design, CRUD operations that work without connectivity, and consideration for storage limitations on mobile devices. Focus on providing a seamless experience where users can access and modify their data regardless of connection status.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Build Fallback Mechanisms for Online Features",
          "description": "Develop graceful degradation strategies for features that typically require connectivity",
          "dependencies": [
            1,
            2
          ],
          "details": "Identify features that normally require online connectivity and create fallback implementations. This includes designing alternative UX flows, implementing placeholder content, queuing actions for later execution, and providing clear feedback to users about limited functionality while maintaining core app usability.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Create Data Synchronization System",
          "description": "Develop a robust synchronization mechanism to reconcile local and server data when connectivity is restored",
          "dependencies": [
            2
          ],
          "details": "Build a bidirectional synchronization system that handles conflict resolution, manages data integrity, and efficiently updates both local and server databases. This should include tracking changes made offline, implementing retry mechanisms for failed syncs, and ensuring data consistency across devices.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement Connectivity Detection and Mode Switching",
          "description": "Create a system to detect network status changes and seamlessly transition between online and offline modes",
          "dependencies": [
            3,
            4
          ],
          "details": "Develop reliable connectivity monitoring that can detect network status changes and trigger appropriate application behaviors. This includes implementing event listeners for connectivity changes, creating smooth transitions between modes without disrupting user experience, and providing clear indicators of current connectivity status to users.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 16,
      "title": "Implement Comprehensive Test Suite",
      "description": "Develop unit, integration, and performance tests for all components.",
      "details": "Write tests for UI, backend, TTS, audio processing, and API integration. Include performance benchmarks for large files.",
      "testStrategy": "Run automated tests and performance benchmarks. Monitor code coverage and test results.",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 17,
      "title": "Implement Documentation and Help System",
      "description": "Create user and developer documentation, and add in-app help.",
      "details": "Write README, user guides, and API docs. Add in-app help and tooltips.",
      "testStrategy": "Review documentation for completeness and accuracy. Test in-app help features.",
      "priority": "low",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 18,
      "title": "Implement Comprehensive UI Design System Matching Provided Mockups",
      "description": "Develop a complete UI design system that precisely matches the provided mockups, including color scheme, layout, typography, iconography, and all visual elements. Create reusable components for all UI elements to ensure consistency across the application. Developers must directly reference the UI mockup images located in the Project/UI Mockups/ directory during implementation. Each screen and component must be compared against these exact images for visual accuracy. The following mockups must be referenced for their respective interfaces:\n\n- book-import-screen.png: Book import interface\n- character-voice-screen.png: Character voice assignment interface\n- export-screen.png: Audiobook export interface\n- text-editor-screen.png: Text editor and dialogue detection interface\n- ui-mockup.png: Project overview and general UI elements\n\nPixel-perfect implementation is required, including exact colors, spacing, typography, and component styling as depicted in these mockups.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Begin by analyzing the provided mockups in the Project/UI Mockups/ directory to extract the exact color palette (with emphasis on the green scheme), spacing, layout grid, typography styles, iconography, and all visual elements. For each interface, developers must reference the corresponding mockup image:\n\n- book-import-screen.png for the book import interface\n- character-voice-screen.png for the character voice assignment interface\n- export-screen.png for the audiobook export interface\n- text-editor-screen.png for the text editor and dialogue detection interface\n- ui-mockup.png for the project overview and general UI elements\n\nImplement a card-based layout with rounded corners, ensuring all components (buttons, cards, toggles, dropdowns, etc.) are built as reusable, modular components in the chosen framework. Use design tokens to standardize colors, spacing, and typography for maintainability and scalability. Document each component with usage guidelines and examples, referencing the relevant mockup image for visual comparison. Collaborate closely with designers to resolve ambiguities and ensure pixel-perfect fidelity to the mockups. Ensure the system is flexible enough for future expansion but enforces strict visual consistency throughout the application. Integrate the design system into the existing three-panel UI structure from Task 2. Provide comprehensive documentation and onboarding materials for developers and designers, explicitly instructing them to use the mockup images as the baseline for all visual decisions.",
      "testStrategy": "Verify that every visual and interactive element in the application matches the provided mockups exactly in terms of color, spacing, layout, and style by directly comparing the implementation to the corresponding images in the Project/UI Mockups/ directory. Use pixel-by-pixel comparison tools to ensure fidelity. Test all reusable components in isolation (e.g., via Storybook) and within the application context to confirm consistency and correct behavior. Review documentation for completeness and clarity, ensuring each component's documentation references the relevant mockup image. Conduct usability testing with team members to ensure the system is easy to use and enforces consistency. Confirm that new UI elements can be built using only the provided components and tokens, maintaining the intended visual hierarchy and style as depicted in the mockups.",
      "subtasks": []
    }
  ]
}